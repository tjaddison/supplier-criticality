import { NextRequest, NextResponse } from 'next/server'
import Papa from 'papaparse'
import {
  createUploadAuditLog,
  updateUploadAuditLog,
  getUserSuppliers,
  replaceAllUserSuppliers
} from '@/lib/dynamodb'
import {
  CSV_REQUIRED_HEADERS,
  CSV_OPTIONAL_HEADERS,
  ROLE_LIMITS,
  ValidationError
} from '@/types/upload-audit'
import { Supplier } from '@/types/supplier'
import { calculateCriticalityScore } from '@/lib/utils/calculations'
import { createAPIHandler } from '@/lib/api-auth'

interface CSVRow {
  [key: string]: string
}

function validateCSVHeaders(headers: string[]): string[] {
  const errors: string[] = []
  const normalizedHeaders = headers.map(h => h.toLowerCase().trim())

  // Check for required headers
  for (const required of CSV_REQUIRED_HEADERS) {
    if (!normalizedHeaders.includes(required.toLowerCase())) {
      errors.push(`Missing required header: ${required}`)
    }
  }

  // Check for unknown headers
  const validHeaders = [...CSV_REQUIRED_HEADERS, ...CSV_OPTIONAL_HEADERS].map(h => h.toLowerCase())
  for (const header of normalizedHeaders) {
    if (header && !validHeaders.includes(header)) {
      errors.push(`Unknown header: ${header}`)
    }
  }

  return errors
}

function validateCSVRow(row: CSVRow, index: number): ValidationError[] {
  const errors: ValidationError[] = []

  // Validate required fields
  for (const field of CSV_REQUIRED_HEADERS) {
    const value = row[field]?.trim()
    if (!value) {
      errors.push({
        row: index + 1,
        field,
        value: value || '',
        error: `${field} is required`
      })
    }
  }

  // Validate data types and formats
  const threeYearSpend = row.threeYearSpend?.trim()
  if (threeYearSpend && isNaN(Number(threeYearSpend))) {
    errors.push({
      row: index + 1,
      field: 'threeYearSpend',
      value: threeYearSpend,
      error: 'threeYearSpend must be a valid number'
    })
  }

  // Validate date format (basic check)
  const expirationDate = row.expirationDate?.trim()
  if (expirationDate && isNaN(Date.parse(expirationDate))) {
    errors.push({
      row: index + 1,
      field: 'expirationDate',
      value: expirationDate,
      error: 'expirationDate must be a valid date (YYYY-MM-DD format recommended)'
    })
  }

  return errors
}

function convertCSVRowToSupplier(row: CSVRow): Supplier {
  return {
    id: '', // Will be generated by DynamoDB function
    name: row.name?.trim() || '',
    category: row.category?.trim() || '',
    subcategory: row.subcategory?.trim() || '',
    expirationDate: row.expirationDate?.trim() || '',
    contractNumber: row.contractNumber?.trim() || '',
    threeYearSpend: Number(row.threeYearSpend?.trim() || 0),
    contractDescription: row.contractDescription?.trim() || '',
    criticalityScore: 0 // Will be calculated later
  }
}

export const POST = createAPIHandler(async (request: NextRequest, user) => {
  const startTime = Date.now()
  let auditLogId: string | null = null
  const userId = user.id

  try {
    const userRole = user.role || 'free'
    const maxSuppliers = ROLE_LIMITS[userRole] || ROLE_LIMITS.free

    // Parse form data
    const formData = await request.formData()
    const file = formData.get('file') as File

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 })
    }

    if (!file.name.toLowerCase().endsWith('.csv')) {
      return NextResponse.json({ error: 'File must be a CSV' }, { status: 400 })
    }

    // Read file content
    const fileContent = await file.text()

    // Create initial audit log
    const existingSuppliers = await getUserSuppliers(userId)
    const auditLog = await createUploadAuditLog(userId, {
      filename: file.name,
      uploadDate: new Date().toISOString(),
      uploadDuration: 0,
      recordsAttempted: 0,
      recordsSuccessful: 0,
      recordsFailed: 0,
      status: 'in_progress',
      errorDetails: [],
      validationErrors: [],
      criticialityScoresRecalculated: false,
      previousRecordCount: existingSuppliers.length,
      newRecordCount: 0
    })

    auditLogId = auditLog.id

    // Parse CSV
    const parseResult = Papa.parse<CSVRow>(fileContent, {
      header: true,
      skipEmptyLines: true,
      transformHeader: (header: string) => header.trim()
    })

    if (parseResult.errors.length > 0) {
      const errorDetails = parseResult.errors.map(err => `Line ${err.row}: ${err.message}`)
      await updateUploadAuditLog(userId, auditLogId, {
        status: 'failed',
        errorDetails,
        uploadDuration: Date.now() - startTime
      })

      return NextResponse.json({
        success: false,
        error: 'CSV parsing failed',
        details: errorDetails
      }, { status: 400 })
    }

    const csvData = parseResult.data
    const recordsAttempted = csvData.length

    // Validate headers
    const headers = parseResult.meta.fields || []
    const headerErrors = validateCSVHeaders(headers)

    if (headerErrors.length > 0) {
      await updateUploadAuditLog(userId, auditLogId, {
        status: 'failed',
        errorDetails: headerErrors,
        recordsAttempted,
        uploadDuration: Date.now() - startTime
      })

      return NextResponse.json({
        success: false,
        error: 'Invalid CSV headers',
        details: headerErrors
      }, { status: 400 })
    }

    // Check role-based limits
    if (maxSuppliers !== Infinity && recordsAttempted > maxSuppliers) {
      const errorMessage = `Your ${userRole} plan allows up to ${maxSuppliers} suppliers. Your CSV contains ${recordsAttempted} records. Please upgrade your plan or reduce the number of suppliers.`

      await updateUploadAuditLog(userId, auditLogId, {
        status: 'failed',
        errorDetails: [errorMessage],
        recordsAttempted,
        uploadDuration: Date.now() - startTime
      })

      return NextResponse.json({
        success: false,
        error: 'Supplier limit exceeded',
        details: [errorMessage],
        userRole,
        maxSuppliers,
        attemptedRecords: recordsAttempted
      }, { status: 400 })
    }

    // Validate each row
    const validationErrors: ValidationError[] = []
    const validSuppliers: Supplier[] = []

    for (let i = 0; i < csvData.length; i++) {
      const row = csvData[i]
      const rowErrors = validateCSVRow(row, i)

      if (rowErrors.length > 0) {
        validationErrors.push(...rowErrors)
      } else {
        const supplier = convertCSVRowToSupplier(row)
        validSuppliers.push(supplier)
      }
    }

    if (validationErrors.length > 0) {
      await updateUploadAuditLog(userId, auditLogId, {
        status: 'failed',
        validationErrors,
        recordsAttempted,
        recordsFailed: validationErrors.length,
        uploadDuration: Date.now() - startTime
      })

      return NextResponse.json({
        success: false,
        error: 'Validation errors found',
        validationErrors,
        recordsAttempted,
        recordsFailed: validationErrors.length
      }, { status: 400 })
    }

    // Calculate criticality scores for valid suppliers
    // Note: This is a simplified calculation - you may want to get user's criteria weights
    const suppliersWithScores = validSuppliers.map(supplier => ({
      ...supplier,
      criticalityScore: calculateCriticalityScore(supplier, {
        spendPercentage: 20,
        threeYearAverage: 30,
        marketSize: 5,
        replacementComplexity: 10,
        utilization: 10,
        riskLevel: 25
      })
    }))

    // Replace all user suppliers
    const replacementResult = await replaceAllUserSuppliers(userId, suppliersWithScores)

    // Update audit log with success
    await updateUploadAuditLog(userId, auditLogId, {
      status: 'completed',
      recordsAttempted,
      recordsSuccessful: validSuppliers.length,
      recordsFailed: 0,
      criticialityScoresRecalculated: true,
      newRecordCount: replacementResult.newCount,
      uploadDuration: Date.now() - startTime
    })

    return NextResponse.json({
      success: true,
      message: 'CSV upload completed successfully',
      recordsProcessed: validSuppliers.length,
      previousCount: replacementResult.previousCount,
      newCount: replacementResult.newCount,
      uploadDuration: Date.now() - startTime
    })

  } catch (error) {
    console.error('CSV upload error:', error)

    // Update audit log with error if we have one
    if (auditLogId) {
      try {
        await updateUploadAuditLog(userId, auditLogId, {
          status: 'failed',
          errorDetails: [error instanceof Error ? error.message : 'Unknown error occurred'],
          uploadDuration: Date.now() - startTime
        })
      } catch (auditError) {
        console.error('Error updating audit log:', auditError)
      }
    }

    return NextResponse.json({
      success: false,
      error: 'Internal server error',
      details: [error instanceof Error ? error.message : 'Unknown error occurred']
    }, { status: 500 })
  }
})

// GET endpoint to download CSV template
export const GET = createAPIHandler(async () => {
  try {

    // Create sample CSV content
    const headers = [...CSV_REQUIRED_HEADERS, ...CSV_OPTIONAL_HEADERS]
    const sampleData = [
      {
        name: 'TechCorp Solutions',
        category: 'Technology',
        subcategory: 'Software Development',
        expirationDate: '2025-12-31',
        contractNumber: 'TC-2024-001',
        threeYearSpend: '2500000',
        contractDescription: 'Enterprise software development and maintenance services'
      },
      {
        name: 'SecureNet Services',
        category: 'Technology',
        subcategory: 'Cybersecurity',
        expirationDate: '2026-06-30',
        contractNumber: 'SN-2024-002',
        threeYearSpend: '1800000',
        contractDescription: 'Comprehensive cybersecurity monitoring and incident response'
      }
    ]

    const csv = Papa.unparse(sampleData, {
      columns: headers
    })

    return new NextResponse(csv, {
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': 'attachment; filename="supplier-template.csv"'
      }
    })

  } catch (error) {
    console.error('Template download error:', error)
    return NextResponse.json({
      error: 'Failed to generate template'
    }, { status: 500 })
  }
})